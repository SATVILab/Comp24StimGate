# Simulation

```{r}
suppressPackageStartupMessages({
  library(tibble)
  library(ggplot2)
})
fn_vec_r <- list.files("R", full.names = TRUE, pattern = "\\.R$")
for (i in seq_along(fn_vec_r)) {
  source(fn_vec_r[i])
}
```

## sim_test Pipeline

This section runs the **sim_test** pipeline - a minimal workflow demonstrating StimGate gating on simulated flow cytometry data. The pipeline:

1. Loads a base flowSet from HDCytoData (Bodenmiller BCR-XL dataset)
2. Generates simulated cytokine expression for BC1 and BC2 markers with well-separated positive/negative populations
3. Creates a GatingSet for StimGate analysis
4. Plots raw expression distributions
5. Runs StimGate automated gating
6. Computes bootstrap statistics comparing actual vs StimGate-estimated proportions
7. Generates correlation plots and gating visualizations

This pipeline should always complete successfully and serves as the first validation after environment setup.

```{r}
Sys.setenv("TAR_PROJECT" = "sim_test")
targets::tar_make(callr_function = NULL)
```

## sim_loop Pipeline

This section runs the **sim_loop** pipeline - an extension of sim_test that runs multiple simulation iterations across different scenarios to compare StimGate against baseline tail-gate methods.

The pipeline runs 5 iterations each of two scenarios:
- **easy**: well-separated positive/negative populations (expr_mean_pos = 2)
- **poor_separation**: overlapping populations (expr_mean_pos = 0.5, higher variance)

For each iteration, the pipeline:

1. Generates simulated flow data using `get_gatingset_from_scratch()`
2. Computes ground truth statistics from known positive cell indices
3. Runs StimGate automated gating
4. Runs tail-gate baseline with multiple tolerance thresholds (10^-9 to 10^-1)
5. Combines all statistics into a single table per iteration

The pipeline then aggregates results across iterations to compute correlation metrics (concordance, Pearson, and Spearman) comparing estimated vs actual proportions for each gating method.

This pipeline is computationally intensive due to the nested loops over simulations and tail-gate tolerance values.
Outputs are cached in `_tmp/targets` for reuse.

```{r}
Sys.setenv("TAR_PROJECT" = "sim_loop")
targets::tar_make(callr_function = NULL)
```

## Results for Easy Scenario

The following plot shows the mean correlation between actual and estimated proportions for each gating method and cytokine combination in the easy scenario. The best-performing tail-gate method (based on any-positive correlations) is selected for comparison against StimGate.

```{r}
corr_tbl_overall <- targets::tar_read(corr_tbl_overall_easy)
corr_tbl_overall_tg_any <- corr_tbl_overall |>
  dplyr::filter(grepl("^tg", gating_method)) |>
  dplyr::filter(type == "any") |>
  dplyr::group_by(gating_method) |>
  dplyr::summarise(
    corr_mean = mean(corr_mean, na.rm = TRUE),
    .groups = "drop"
  ) |>
  dplyr::filter(corr_mean == max(corr_mean)) |>
  dplyr::slice(1) 

corr_tbl_plot <- corr_tbl_overall |>
  dplyr::filter(!grepl("^tg", gating_method)) |>
  dplyr::bind_rows(
    corr_tbl_overall |>
      dplyr::semi_join(
        corr_tbl_overall_tg_any,
        by = c("gating_method")
      ) |>
      dplyr::mutate(
        gating_method = "tg"
      )
  ) |>
  dplyr::ungroup() |>
  dplyr::mutate(
    type = factor(type, levels = c("any", "single", "combn")),
  )
p <- ggplot(corr_tbl_plot, aes(x = cyt, y = corr_mean, fill = gating_method)) +
  cowplot::theme_cowplot() +
  cowplot::background_grid() +
  theme(
    plot.background = element_rect(fill = "white"),
    panel.background = element_rect(fill = "white")
  ) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(corr_method~type, ncol = 3, scales = "free_x") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )
path_p <- projr::projr_path_get("cache", "sim_loop", "plots", "easy-corr_mean_by_cyt.png")
ggsave(
  filename = path_p,
  plot = p,
  width = 10,
  height = 12
)
```

## Results for Poor Separation Scenario

The following plot shows the mean correlation between actual and estimated proportions for each gating method and cytokine combination in the poor separation scenario. This scenario tests how well each gating method performs when positive and negative populations overlap significantly.

```{r}
corr_tbl_overall <- targets::tar_read(corr_tbl_overall_poor_separation)
corr_tbl_overall_tg_any <- corr_tbl_overall |>
  dplyr::filter(grepl("^tg", gating_method)) |>
  dplyr::filter(type == "any") |>
  dplyr::group_by(gating_method) |>
  dplyr::summarise(
    corr_mean = mean(corr_mean, na.rm = TRUE),
    .groups = "drop"
  ) |>
  dplyr::filter(corr_mean == max(corr_mean)) |>
  dplyr::slice(1) 

corr_tbl_plot <- corr_tbl_overall |>
  dplyr::filter(!grepl("^tg", gating_method)) |>
  dplyr::bind_rows(
    corr_tbl_overall |>
      dplyr::semi_join(
        corr_tbl_overall_tg_any,
        by = c("gating_method")
      ) |>
      dplyr::mutate(
        gating_method = "tg"
      )
  ) |>
  dplyr::ungroup() |>
  dplyr::mutate(
    type = factor(type, levels = c("any", "single", "combn")),
  )
p <- ggplot(corr_tbl_plot, aes(x = cyt, y = corr_mean, fill = gating_method)) +
  cowplot::theme_cowplot() +
  cowplot::background_grid() +
  theme(
    plot.background = element_rect(fill = "white"),
    panel.background = element_rect(fill = "white")
  ) +
  geom_bar(stat = "identity", position = "dodge") +
  facet_wrap(corr_method~type, ncol = 3, scales = "free_x") +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1),
    legend.position = "bottom"
  )
path_p <- projr::projr_path_get("cache", "sim_loop", "plots", "poor_separation-corr_mean_by_cyt.png")
ggsave(
  filename = path_p,
  plot = p,
  width = 10,
  height = 12
)
```
